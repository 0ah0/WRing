\chapter{Preliminaries}
\label{ch:preliminaries}
\newpage

\section{RDF Model}
The "Semantic Web" \cite{W3C:SemanticWebTerm:Online} term  has appeared during the transformation process of Web Development from "Web of documents" to "Web of data", similar to those data are found in databases. W3C defines it as "the Web of linked data" . {\it Figure \ref{Fig:semanticWebStack} describes the Semantic Web Stack, proposed by W3C. It can be seen, that it contains several technologies to enable users of creating their own data stores on web, building vocabularies, and enforcing processing rules on such data.   
\vspace{5mm} %5mm vertical space
\par
In order to make data more and machine-readable, and easier for interchange, RDF Model \cite{W3C:RDF-Primer:Online} has been proposed. RDF Model plays the role of data interchange in the layered Semantic Web Stack and leverages the high-level with low-level semantic web tools as it is shown in {\it Figure \ref{Fig:semanticWebStack}. 

	\begin{figure}[ht]
	\begin{center}
		\includegraphics[scale=0.5,angle=0]{images/semanticWebStack}
		\caption{The Semantic Web Stack \cite{Bratt2007}}
		\label{Fig:semanticWebStack}
	\end{center}
\end{figure}
\vspace{12mm} %5mm vertical space
\par
{\it Figure \ref{Fig:rdfModel}(a) exhibits RDF Model's representation of data in triples. A triple is defined by 3 main players: subject, predicate, and object. It has a common similarity of a basic structure of simple sentence which consists of a subject, an object, and a verb. As the verb shows a relation or an event between the other two entities, similar, the predicate connects both subject and object in a certain relation. 
	
\begin{figure}[ht]
	\begin{center}
		\includegraphics[scale=0.4,angle=0]{images/RDF-Model}
		\caption{RDF Model's Structure}
		\label{Fig:rdfModel}
	\end{center}
\end{figure}
 
A similar Resource-Property-Value structure to Subject-Predicate-Object of RDF Model's representation is drawn in {\it Figure \ref{Fig:rdfModel}(b). It is same representation but Subject, Predicate, and Object are replaced with Resource, Property, and Value in sequence.  
\subsection{Simple RDF Model Example}

To make it more clear, a simple example of RDF Modeling is giving in {\it Figure \ref{Fig:rdfModel}(c). To represent a fact that "German has The Rhein river", Ex:Germany is Subject/Resource, Ex:hasRiver is Predicate/Property, and "Rhein" is Object/Value. The first two value are Uniform Resource Identifiers (URIs) where "Ex:" is a defined path in RDF files and the following part is an extension of the path. The last value "Rhein" is a literal or a string. More examples can be viewed at \cite{W3C:RDF-Primer:Online}

\section{Parsing and Error Recovery}
\subsection{Parsing and Grammar Definitions}
It is of great benefit to shed a little light on parsing topic to understand later the approach of this study. In \cite{parsingGuide2017}, Gabriele Tomassetti has defined \textbf{Parsing} by:

	\textbf{``The analysis of an input to organize the data according to the rule of a grammar''}. It can be intelligibly recognized that parsing deals with some input data and tries to analyses it based on a given grammer. let's have a look on the definition of grammer based on  \cite{parsingGuide2017}. \textbf{Grammer} is 
\textbf{``A formal grammar is a set of rules that describes syntactically a language''}. In the definition, rules are the significant part of the grammar to define the language's syntax.  
\subsection{Parser's Role}
The parser is an essential part in a compiler. Figure \ref*{Fig:parserPosition} draws the role of the parser in a compiler. The first phase "Lexical Analyzer" receives the input data, then produces tokens for the next phase "Parser". Parser constructs a parse tree based on its grammar rules and gets the next token till it consumes all tokens. The parse tree as an parser's output is delivered to the next phases of a compiler. If any errors are found, lexical errors can be generated by Lexical Analyzer and Parser is the producer of both Syntax and semantic errors.%TODO{we can add more declartion about symbol table}
 A symbol table is data structure entries to store some declared values in the input, such as in programming languages object and variable names. It is used by both  Lexical Analyzer and Parser as it is shown in Figure \ref*{Fig:parserPosition}.
%TODO{add the ref or change the image}

\begin{figure}[ht]
	\begin{center}
		\includegraphics[scale=0.5,angle=0]{images/ParserRole}
		\caption{The Role of Parser}
		\label{Fig:parserPosition}
	\end{center}
\end{figure}
\subsection{Parser's Constructions}
In order to build a parser, there are two options to get such objective, either by building your own hand-written parser or getting an off-the-shelf parser generator tool. follows both approaches are discussed:
\par \textbf{1) Hand-writing Parsers:} someone writes his own parser, including the lexical analyzer and the parser. On the one hand this way gives more flexibility in handling several problems triggered during development but on the other hand it consumes much time and mind.
\par \textbf{2) Parser Generators:} someone uses a tool to generate a parser to do specific parsing task, by writing a compilable grammar to such tool. The most advantage of using those tools is the less consumed time to build a parser.  

\subsection{Error Recovery Methodologies in Parsers}
Error Recovery Strategies are the behavior of a system once an error is detected. Compiler's researchers Aho et al \cite{Aho2006}  have classified such methodologies as follows:
\begin{itemize}
	\item \textbf{Panic-Mode Recovery}: Once an error has been discovered, the parser ignores and skips next input symbols one by one till a recognized set of tokens is detected. In spite of discarding sometimes huge amount of input symbols with checking them for further error detection, it is considered a simple parsing mode and do not fall in an infinite loop while other modes may do.
	\item \textbf{Phrase-Level Recovery}: To continue the parsing process, the parser performs local correction. A typical local correction in RDF is to insert a missing dot or delete extraneous dots.
	\item \textbf{Error Productions}: By expecting the common errors, production rules can be inserted into the grammar. Then, the generated parser is well-informed about such errors. Error diagnostics can be easily done in this case since the error in our hand.
	\item \textbf{Global Correction}: The parser tries to reduce as much as possible number of change operations (Insertion, deletion or modification) when dealing with an incorrect input token to reduce globally total cost of error correction. To make it more clear, let's assume an incorrect input statement X is giving in grammar G, the parser constructs a closest error-free parse tree of statement Y to replace statment X, such that changes are small as possible. 
\end{itemize}


\section{ANTLR Parser Generator }
ANTLR is an handy tool and easy way to generate a specific domain language parser. It is an parser generator to do automatic generation of a source code of such parser without much coding and with less time. The basic principle used by ANTLR is define language's rules which draws the syntax and the semantic of the language the parser build for. 

\vspace{5mm} %5mm vertical space
\par
 As has been previously discussed, the compiler has two main subsystems: lexer and parser. Both lexer and parser are needed to have their rules defined in ANTLR grammar file.  Figure \ref*{Fig:ANTLR} demonstrates an auto-generated parser program, generated based on ANTLR tool. follows is a sequence steps, describes such parsing process:

\begin{figure}[ht]
	\begin{center}
		\includegraphics[scale=0.4]{images/ANTLR}
		\caption{Parsing process based on ANTLR parser generator}
		\label{Fig:ANTLR}
	\end{center}
\end{figure}


\begin{enumerate}
		
		\item  {\bf Writing a grammar file:} ordinarily a grammar called a parsing expression grammar, or PEG is required to build a parser. 
		\item {\bf Generation of recognizer classes by ANTLR generator: }
		\item {\bf Feeding an input file for parsing: }
		\item {\bf Parsing procedure: }
		\item {\bf Delivering of a report and parse tree as an output: }
	\end{enumerate}











